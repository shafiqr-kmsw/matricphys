<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Motion 3D Learning Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .game-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid rgba(255, 255, 255, 0.1);
        }

        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .controls {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.1);
        }

        .view-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-weight: 600;
            font-size: 16px;
            z-index: 10;
            min-width: 150px;
            text-align: center;
        }

        .view-indicator .view-type {
            color: #4CAF50;
            font-size: 18px;
            margin-bottom: 5px;
        }

        .view-indicator .view-description {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #gameCanvas:active {
            cursor: grabbing;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .btn.active {
            background: linear-gradient(45deg, #FF6B6B, #ee5a52);
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 16px;
        }

        .measurement {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }

        .measurement .value {
            font-weight: 600;
            color: #FFD700;
        }

        .scenario-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .scenario-btn {
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .scenario-btn:hover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        .scenario-btn.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.3);
        }

        .unit-converter {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .unit-converter h4 {
            margin-bottom: 10px;
            color: #FFD700;
        }

        .converter-row {
            display: flex;
            gap: 10px;
            margin: 8px 0;
            align-items: center;
        }

        .converter-input {
            flex: 1;
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
        }

        .converter-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .learning-objectives {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .learning-objectives h4 {
            margin-bottom: 10px;
            color: #FFD700;
        }

        .objective {
            margin: 8px 0;
            font-size: 12px;
            padding-left: 15px;
            position: relative;
        }

        .objective::before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #4CAF50;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 40vh;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="sidebar">
            <div class="learning-objectives">
                <h4>üéØ Learning Objectives</h4>
                <div class="objective">Angular displacement & velocity</div>
                <div class="objective">Period & frequency</div>
                <div class="objective">Uniform circular motion</div>
                <div class="objective">Unit conversions</div>
                <div class="objective">Centripetal force</div>
                <div class="objective">Vertical & conical motion</div>
            </div>

            <div class="scenario-selector">
                <div class="scenario-btn active" data-scenario="horizontal">
                    üîÑ Horizontal Circular Motion
                </div>
                <div class="scenario-btn" data-scenario="vertical">
                    üé° Vertical Circular Motion
                </div>
                <div class="scenario-btn" data-scenario="conical">
                    üé™ Conical Pendulum
                </div>
            </div>

            <div class="info-panel">
                <h3>üìä Real-time Measurements</h3>
                <div class="measurement">
                    <span>Angular Velocity (œâ):</span>
                    <span class="value" id="angularVelocity">0.00 rad/s</span>
                </div>
                <div class="measurement">
                    <span>Period (T):</span>
                    <span class="value" id="period">0.00 s</span>
                </div>
                <div class="measurement">
                    <span>Frequency (f):</span>
                    <span class="value" id="frequency">0.00 Hz</span>
                </div>
                <div class="measurement">
                    <span>Centripetal Force:</span>
                    <span class="value" id="centripetalForce">0.00 N</span>
                </div>
                <div class="measurement">
                    <span>Centripetal Acceleration:</span>
                    <span class="value" id="centripetalAccel">0.00 m/s¬≤</span>
                </div>
            </div>

            <div class="unit-converter">
                <h4>üîÑ Unit Converter</h4>
                <div class="converter-row">
                    <input type="number" class="converter-input" id="degrees" placeholder="Degrees" step="0.1">
                    <span>¬∞</span>
                </div>
                <div class="converter-row">
                    <input type="number" class="converter-input" id="radians" placeholder="Radians" step="0.001">
                    <span>rad</span>
                </div>
                <div class="converter-row">
                    <input type="number" class="converter-input" id="revolutions" placeholder="Revolutions" step="0.001">
                    <span>rev</span>
                </div>
            </div>
        </div>

        <div class="main-area">
            <div class="controls">
                <div class="control-group">
                    <label>Radius (m)</label>
                    <input type="range" class="slider" id="radiusSlider" min="0.5" max="3" step="0.1" value="1.5">
                    <span id="radiusValue">1.5</span>
                </div>
                
                <div class="control-group">
                    <label>Mass (kg)</label>
                    <input type="range" class="slider" id="massSlider" min="0.1" max="5" step="0.1" value="1">
                    <span id="massValue">1.0</span>
                </div>
                
                <div class="control-group">
                    <label>Speed (m/s)</label>
                    <input type="range" class="slider" id="speedSlider" min="0.1" max="10" step="0.1" value="2">
                    <span id="speedValue">2.0</span>
                </div>
                
                <button class="btn" id="playPauseBtn">‚ñ∂Ô∏è Start</button>
                <button class="btn" id="resetBtn">üîÑ Reset</button>
                <button class="btn" id="showVectorsBtn">üìê Show Vectors</button>
            </div>
            
            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
                <div class="view-indicator" id="viewIndicator">
                    <div class="view-type" id="viewType">üìê Side View</div>
                    <div id="viewName">Perspective View</div>
                    <div class="view-description" id="viewDescription">Drag to rotate camera</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class CircularMotionGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                // Game state
                this.isPlaying = false;
                this.showVectors = false;
                this.scenario = 'horizontal';
                this.angle = 0;
                this.time = 0;
                
                // Physics parameters
                this.radius = 1.5;
                this.mass = 1.0;
                this.speed = 2.0;
                this.gravity = 9.81;
                
                // Camera controls
                this.cameraAngleX = 0;
                this.cameraAngleY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.setupEventListeners();
                this.setupUnitConverter();
                this.updateViewIndicator(); // Initialize view indicator
                this.animate();
            }
            
            setupCanvas() {
                const resizeCanvas = () => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.canvas.width = rect.width * window.devicePixelRatio;
                    this.canvas.height = rect.height * window.devicePixelRatio;
                    this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }
            
            setupEventListeners() {
                // Control sliders
                document.getElementById('radiusSlider').addEventListener('input', (e) => {
                    this.radius = parseFloat(e.target.value);
                    document.getElementById('radiusValue').textContent = this.radius.toFixed(1);
                });
                
                document.getElementById('massSlider').addEventListener('input', (e) => {
                    this.mass = parseFloat(e.target.value);
                    document.getElementById('massValue').textContent = this.mass.toFixed(1);
                });
                
                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = this.speed.toFixed(1);
                });
                
                // Control buttons
                document.getElementById('playPauseBtn').addEventListener('click', () => {
                    this.isPlaying = !this.isPlaying;
                    const btn = document.getElementById('playPauseBtn');
                    btn.textContent = this.isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Start';
                    btn.classList.toggle('active', this.isPlaying);
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.angle = 0;
                    this.time = 0;
                });
                
                document.getElementById('showVectorsBtn').addEventListener('click', () => {
                    this.showVectors = !this.showVectors;
                    const btn = document.getElementById('showVectorsBtn');
                    btn.classList.toggle('active', this.showVectors);
                });
                
                // Scenario selection
                document.querySelectorAll('.scenario-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.scenario = btn.dataset.scenario;
                        this.angle = 0;
                        this.time = 0;
                    });
                });
                
                // Mouse controls for 3D camera
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const deltaX = e.clientX - this.lastMouseX;
                        const deltaY = e.clientY - this.lastMouseY;
                        
                        this.cameraAngleY += deltaX * 0.01;
                        this.cameraAngleX += deltaY * 0.01;
                        
                        this.cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraAngleX));
                        
                        this.lastMouseX = e.clientX;
                        this.lastMouseY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                });
            }
            
            setupUnitConverter() {
                const degreesInput = document.getElementById('degrees');
                const radiansInput = document.getElementById('radians');
                const revolutionsInput = document.getElementById('revolutions');
                
                degreesInput.addEventListener('input', (e) => {
                    const degrees = parseFloat(e.target.value) || 0;
                    const radians = degrees * Math.PI / 180;
                    const revolutions = degrees / 360;
                    
                    radiansInput.value = radians.toFixed(4);
                    revolutionsInput.value = revolutions.toFixed(4);
                });
                
                radiansInput.addEventListener('input', (e) => {
                    const radians = parseFloat(e.target.value) || 0;
                    const degrees = radians * 180 / Math.PI;
                    const revolutions = radians / (2 * Math.PI);
                    
                    degreesInput.value = degrees.toFixed(2);
                    revolutionsInput.value = revolutions.toFixed(4);
                });
                
                revolutionsInput.addEventListener('input', (e) => {
                    const revolutions = parseFloat(e.target.value) || 0;
                    const radians = revolutions * 2 * Math.PI;
                    const degrees = revolutions * 360;
                    
                    radiansInput.value = radians.toFixed(4);
                    degreesInput.value = degrees.toFixed(2);
                });
            }
            
            updatePhysics(deltaTime) {
                if (!this.isPlaying) return;
                
                this.time += deltaTime;
                
                // Calculate angular velocity
                const angularVelocity = this.speed / this.radius;
                this.angle += angularVelocity * deltaTime;
                
                // Keep angle in range [0, 2œÄ]
                if (this.angle > 2 * Math.PI) {
                    this.angle -= 2 * Math.PI;
                }
                
                // Update measurements
                const period = 2 * Math.PI / angularVelocity;
                const frequency = 1 / period;
                const centripetalAcceleration = this.speed * this.speed / this.radius;
                const centripetalForce = this.mass * centripetalAcceleration;
                
                document.getElementById('angularVelocity').textContent = angularVelocity.toFixed(3) + ' rad/s';
                document.getElementById('period').textContent = period.toFixed(3) + ' s';
                document.getElementById('frequency').textContent = frequency.toFixed(3) + ' Hz';
                document.getElementById('centripetalForce').textContent = centripetalForce.toFixed(2) + ' N';
                document.getElementById('centripetalAccel').textContent = centripetalAcceleration.toFixed(2) + ' m/s¬≤';
                
                // Update view indicator
                this.updateViewIndicator();
            }
            
            updateViewIndicator() {
                const viewTypeEl = document.getElementById('viewType');
                const viewNameEl = document.getElementById('viewName');
                const viewDescEl = document.getElementById('viewDescription');
                
                // Normalize angles to [0, 2œÄ]
                const normalizedX = ((this.cameraAngleX % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                const normalizedY = ((this.cameraAngleY % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                
                // Determine view based on camera angles
                const threshold = Math.PI / 8; // 22.5 degrees tolerance
                
                // Check for top view (looking down)
                if (Math.abs(normalizedX - Math.PI/2) < threshold || Math.abs(normalizedX - (3*Math.PI/2)) < threshold) {
                    viewTypeEl.textContent = 'üîΩ Top View';
                    viewNameEl.textContent = 'Bird\'s Eye View';
                    viewDescEl.textContent = 'Looking down at the motion';
                }
                // Check for bottom view (looking up)
                else if (Math.abs(normalizedX + Math.PI/2) < threshold || Math.abs(normalizedX - (Math.PI/2)) < threshold) {
                    viewTypeEl.textContent = 'üîº Bottom View';
                    viewNameEl.textContent = 'Worm\'s Eye View';
                    viewDescEl.textContent = 'Looking up at the motion';
                }
                // Check for side views
                else if (Math.abs(normalizedX) < threshold || Math.abs(normalizedX - 2*Math.PI) < threshold) {
                    // Determine which side based on Y rotation
                    if (Math.abs(normalizedY) < threshold || Math.abs(normalizedY - 2*Math.PI) < threshold) {
                        viewTypeEl.textContent = 'üìê Side View';
                        viewNameEl.textContent = 'Front View';
                        viewDescEl.textContent = 'Looking from the front';
                    } else if (Math.abs(normalizedY - Math.PI) < threshold) {
                        viewTypeEl.textContent = 'üìê Side View';
                        viewNameEl.textContent = 'Back View';
                        viewDescEl.textContent = 'Looking from behind';
                    } else if (Math.abs(normalizedY - Math.PI/2) < threshold) {
                        viewTypeEl.textContent = 'üìê Side View';
                        viewNameEl.textContent = 'Right Side View';
                        viewDescEl.textContent = 'Looking from the right';
                    } else if (Math.abs(normalizedY - 3*Math.PI/2) < threshold) {
                        viewTypeEl.textContent = 'üìê Side View';
                        viewNameEl.textContent = 'Left Side View';
                        viewDescEl.textContent = 'Looking from the left';
                    } else {
                        viewTypeEl.textContent = 'üìê Side View';
                        viewNameEl.textContent = 'Angled Side View';
                        viewDescEl.textContent = 'Side perspective';
                    }
                }
                // Default perspective view
                else {
                    viewTypeEl.textContent = 'üéØ Perspective View';
                    viewNameEl.textContent = '3D Perspective';
                    viewDescEl.textContent = 'Angled 3D view';
                }
            }
            
            project3D(x, y, z) {
                // Simple 3D to 2D projection with camera rotation
                const cosX = Math.cos(this.cameraAngleX);
                const sinX = Math.sin(this.cameraAngleX);
                const cosY = Math.cos(this.cameraAngleY);
                const sinY = Math.sin(this.cameraAngleY);
                
                // Rotate around Y axis
                const x1 = x * cosY - z * sinY;
                const z1 = x * sinY + z * cosY;
                
                // Rotate around X axis
                const y2 = y * cosX - z1 * sinX;
                const z2 = y * sinX + z1 * cosX;
                
                // Project to 2D
                const scale = 100;
                const centerX = this.canvas.width / (2 * window.devicePixelRatio);
                const centerY = this.canvas.height / (2 * window.devicePixelRatio);
                
                return {
                    x: centerX + x1 * scale,
                    y: centerY - y2 * scale,
                    z: z2
                };
            }
            
            drawVector(startX, startY, endX, endY, color, label) {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Arrow head
                const angle = Math.atan2(endY - startY, endX - startX);
                const headLength = 15;
                this.ctx.beginPath();
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI/6), endY - headLength * Math.sin(angle - Math.PI/6));
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI/6), endY - headLength * Math.sin(angle + Math.PI/6));
                this.ctx.stroke();
                
                // Label
                this.ctx.fillStyle = color;
                this.ctx.font = '14px Arial';
                this.ctx.fillText(label, endX + 10, endY - 10);
            }
            
            render() {
                const width = this.canvas.width / window.devicePixelRatio;
                const height = this.canvas.height / window.devicePixelRatio;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, width, height);
                
                // Draw coordinate system
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                
                // Grid
                for (let i = -5; i <= 5; i++) {
                    const start = this.project3D(i, 0, -5);
                    const end = this.project3D(i, 0, 5);
                    this.ctx.beginPath();
                    this.ctx.moveTo(start.x, start.y);
                    this.ctx.lineTo(end.x, end.y);
                    this.ctx.stroke();
                    
                    const start2 = this.project3D(-5, 0, i);
                    const end2 = this.project3D(5, 0, i);
                    this.ctx.beginPath();
                    this.ctx.moveTo(start2.x, start2.y);
                    this.ctx.lineTo(end2.x, end2.y);
                    this.ctx.stroke();
                }
                
                // Draw based on scenario
                if (this.scenario === 'horizontal') {
                    this.drawHorizontalMotion();
                } else if (this.scenario === 'vertical') {
                    this.drawVerticalMotion();
                } else if (this.scenario === 'conical') {
                    this.drawConicalPendulum();
                }
            }
            
            drawHorizontalMotion() {
                // Draw circular path
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                const points = [];
                for (let i = 0; i <= 64; i++) {
                    const a = (i / 64) * 2 * Math.PI;
                    const x = this.radius * Math.cos(a);
                    const z = this.radius * Math.sin(a);
                    points.push(this.project3D(x, 0, z));
                }
                
                this.ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                this.ctx.stroke();
                
                // Draw object
                const objX = this.radius * Math.cos(this.angle);
                const objZ = this.radius * Math.sin(this.angle);
                const objPos = this.project3D(objX, 0, objZ);
                
                this.ctx.fillStyle = '#FF6B6B';
                this.ctx.beginPath();
                this.ctx.arc(objPos.x, objPos.y, 12, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw center point with enhanced visibility
                const center = this.project3D(0, 0, 0);
                
                // Outer glow
                this.ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(center.x, center.y, 15, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Main center point
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.beginPath();
                this.ctx.arc(center.x, center.y, 8, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Inner highlight
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(center.x - 2, center.y - 2, 3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Center label
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.fillText('CENTER', center.x + 20, center.y + 5);
                
                // Draw vectors if enabled
                if (this.showVectors) {
                    // Velocity vector (tangent)
                    const velX = -this.radius * Math.sin(this.angle);
                    const velZ = this.radius * Math.cos(this.angle);
                    const velMag = this.speed / 5; // Scale for display
                    const velEnd = this.project3D(objX + velX * velMag, 0, objZ + velZ * velMag);
                    this.drawVector(objPos.x, objPos.y, velEnd.x, velEnd.y, '#00FF00', 'v');
                    
                    // Centripetal force vector (toward center)
                    const forceScale = 0.3;
                    const forceEnd = this.project3D(objX - objX * forceScale, 0, objZ - objZ * forceScale);
                    this.drawVector(objPos.x, objPos.y, forceEnd.x, forceEnd.y, '#FF00FF', 'Fc');
                }
            }
            
            drawVerticalMotion() {
                // Draw circular path (vertical)
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                const points = [];
                for (let i = 0; i <= 64; i++) {
                    const a = (i / 64) * 2 * Math.PI;
                    const x = this.radius * Math.cos(a);
                    const y = this.radius * Math.sin(a);
                    points.push(this.project3D(x, y, 0));
                }
                
                this.ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                this.ctx.stroke();
                
                // Draw object
                const objX = this.radius * Math.cos(this.angle);
                const objY = this.radius * Math.sin(this.angle);
                const objPos = this.project3D(objX, objY, 0);
                
                this.ctx.fillStyle = '#FF6B6B';
                this.ctx.beginPath();
                this.ctx.arc(objPos.x, objPos.y, 12, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw center point with enhanced visibility
                const center = this.project3D(0, 0, 0);
                
                // Outer glow
                this.ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(center.x, center.y, 15, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Main center point
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.beginPath();
                this.ctx.arc(center.x, center.y, 8, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Inner highlight
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(center.x - 2, center.y - 2, 3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Center label
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.fillText('CENTER', center.x + 20, center.y + 5);
                
                // Draw vectors if enabled
                if (this.showVectors) {
                    // Gravity vector
                    const gravEnd = this.project3D(objX, objY - 0.5, 0);
                    this.drawVector(objPos.x, objPos.y, gravEnd.x, gravEnd.y, '#FFFF00', 'mg');
                    
                    // Normal force (varies with position)
                    const normalMag = 0.4 + 0.3 * Math.cos(this.angle);
                    const normalEnd = this.project3D(objX - objX * normalMag / this.radius, objY - objY * normalMag / this.radius, 0);
                    this.drawVector(objPos.x, objPos.y, normalEnd.x, normalEnd.y, '#00FFFF', 'N');
                }
            }
            
            drawConicalPendulum() {
                const coneAngle = Math.PI / 6; // 30 degrees
                const stringLength = 2;
                const verticalHeight = stringLength * Math.cos(coneAngle);
                
                // Draw vertical reference line (dashed)
                const topPos = this.project3D(0, verticalHeight, 0);
                const bottomPos = this.project3D(0, -0.5, 0);
                
                this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([10, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(topPos.x, topPos.y);
                this.ctx.lineTo(bottomPos.x, bottomPos.y);
                this.ctx.stroke();
                this.ctx.setLineDash([]); // Reset line dash
                
                // Add vertical line label
                this.ctx.fillStyle = '#FFFF00';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.fillText('Vertical', bottomPos.x + 10, bottomPos.y + 15);
                
                // Draw string
                const objX = this.radius * Math.cos(this.angle);
                const objZ = this.radius * Math.sin(this.angle);
                const objPos = this.project3D(objX, 0, objZ);
                
                this.ctx.strokeStyle = '#FFFFFF';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(topPos.x, topPos.y);
                this.ctx.lineTo(objPos.x, objPos.y);
                this.ctx.stroke();
                
                // Angle arc removed for cleaner visualization
                
                // Draw circular path
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                const points = [];
                for (let i = 0; i <= 64; i++) {
                    const a = (i / 64) * 2 * Math.PI;
                    const x = this.radius * Math.cos(a);
                    const z = this.radius * Math.sin(a);
                    points.push(this.project3D(x, 0, z));
                }
                
                this.ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                this.ctx.stroke();
                
                // Draw object
                this.ctx.fillStyle = '#FF6B6B';
                this.ctx.beginPath();
                this.ctx.arc(objPos.x, objPos.y, 12, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw pivot point
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.beginPath();
                this.ctx.arc(topPos.x, topPos.y, 6, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw vectors if enabled
                if (this.showVectors) {
                    // Tension components
                    const tension = this.mass * this.gravity / Math.cos(coneAngle);
                    const tensionScale = 0.3;
                    
                    // Vertical component (balances weight)
                    const tensionVertEnd = this.project3D(objX, tensionScale, objZ);
                    this.drawVector(objPos.x, objPos.y, tensionVertEnd.x, tensionVertEnd.y, '#00FFFF', 'T cos Œ∏');
                    
                    // Horizontal component (centripetal force)
                    const tensionHorEnd = this.project3D(objX - objX * tensionScale, 0, objZ - objZ * tensionScale);
                    this.drawVector(objPos.x, objPos.y, tensionHorEnd.x, tensionHorEnd.y, '#FF00FF', 'T sin Œ∏');
                    
                    // Weight
                    const weightEnd = this.project3D(objX, -tensionScale, objZ);
                    this.drawVector(objPos.x, objPos.y, weightEnd.x, weightEnd.y, '#FFFF00', 'mg');
                }
            }
            
            animate() {
                const currentTime = Date.now();
                const deltaTime = this.lastTime ? (currentTime - this.lastTime) / 1000 : 0;
                this.lastTime = currentTime;
                
                this.updatePhysics(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize the game when the page loads
        window.addEventListener('load', () => {
            new CircularMotionGame();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9707d820f41c14eb',t:'MTc1NTQxOTc5MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
